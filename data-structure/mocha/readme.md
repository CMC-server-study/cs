# 자료구조

## Array
데이터를 메모리 상에 연속적이고 순차적으로 미리 할당된 크기만큼 저장하는 자료 구조

**장점**
- 데이터 조회가 빠르다 -> 시간 복잡도 O(1)
- 데이터 추가(append)가 빠르다 -> 시간 복잡도 O(1)
- 마지막 데이터 삭제가 빠르다 -> 시간 복잡도 O(1)

**단점**
- 미리 고정된 크기의 배열을 할당하므로, 배열의 크기를 넘어서는 데이터가 추가되면 새로운 배열을 생성 후 기존 데이터를 복사하는 과정을 거쳐야 한다.
- 배열 중간에 데이터 삽입하는 과정이 느리다 -> 시간복잡도 O(n)- 배열 중간의 데이터를 삭제하는 과정이 느리다 -> 시간복잡도 O(n)

## LinkedList
데이터를 메모리 상의 비연속적인 공간에 할당하지만, LinkedList를 구성하는 노드가 다음 노드를 가리킴으로써 논리적인 연속성을 가진 자료구조

**장점**

- 삽입과 삭제 과정 시, 다른 데이터들의 이동 없이 포인터가 가리키는 값만 바꿔주면 되기 때문에 O(1)의 시간복잡도가 걸린다.

**단점**
- Array처럼 메모리 상의 연속적인 공간에 데이터가 할당되어있지 않기 때문에 랜덤 액세스가 불가능하다. 따라서 조회 시 처음부터 탐색해야 하고 O(n)의 시간복잡도가 걸린다.


## Array vs ArrayList 차이

| .      | Array                          | 	ArrayList                            |
|--------|--------------------------------|---------------------------------------|
| 사이즈    | 	고정된 크기로 초기화                   | 	크기가 가변적임                             |
| 속도     | 	초기화시 메모리에 할당되어서 ArrayList보다 빠름 | 	데이터 추가 삭제시 메모리가 할당되기 때문에 Array 보다는 느림 |
| 사이즈 변경 | 	불가능                           | 	유동적으로 변경 가능                          |

**ArrayList 세부 사항**
- ArrayList의 경우 Default 사이즈는 10개로 시작한다.
- ArrayList 내부에는 사이즈를 나타내는 capacity 변수가 있고, 배열의 길이만큼 capacity가 늘어나면 기존 배열 크기에서 1.5배인 새로운 배열을 만들어서 복사한다.

## HashTable
Hash table은 효율적인 탐색을 위한 자료구조로써 key-value쌍의 데이터를 입력받는다.
- 저장 : 시간 복잡도 O(1)
- 삭제 : 시간 복잡도 O(1)
- 검색 : 시간 복잡도 O(1)

> 기본적으로 O(1)의 시간복잡도를 가지지만, 해시 충돌이 발생할 경우 O(N)까지 올라갈 수 있다.

**Hash Collision의 발생 이유**
- 저장하는 모든 값들에 대해서 고유한 해시값을 할당해줄 수 있다면 시간 복잡도는 항상 O(1)을 유지할 것이다. 하지만, 모든 경우의 수를 고려해서 해시 테이블을 초기 할당한다면 너무나 많은 메모리 공간이 소요될 것이다. 따라서 해시 테이블은 모든 경우의 수를 포함할 수는 없는 적당한 메모리 공간을 확보했고, 결과적으로 곂치는 값이 발생해서 해시 충돌이 발생할 수 있다.

### Hash Collision 해결법

### Open Addressing

![스크린샷 2023-04-12 오후 8 26 21](https://user-images.githubusercontent.com/82302520/231447289-eae4790a-dc77-4aa6-acce-492621751586.png)

Collision이 발생하면 미리 정학 규칙에 따라 hash table의 비어있는 공간을 찾는다.

**Open Addressing 종류**
- Linear Probing(선형조사법) : 충돌이 발생한 해시값으로 부터 +1,+2 ... 씩 건너뛰며 비어있는 공간을 찾아서 값을 저장하는 방식이다.
- Quadratic Probing(이차조사법) : 충돌이 발생한 해시값으로부터 1^2 + 2^2 ... 씩 건너 뛰며 비어있는 공간을 찾아서 값을 저장하는 방식이다.
- Double Hashing : Linear Probing과 Quadratic Probing은 같은 간격으로 이동하기 때문에 클러스터링 문제가 발생할 수 있다. 따라서 간격 자체에 해시를 한번 더 적용하는 방식을 이중 해시라고 한다.

> Open Addressing 방식은 Seperate Chaining 방식과 다르게 추가적인 메모리 공간을 필요로 하지 않는다.

### Seperate Chaining

![스크린샷 2023-04-12 오후 8 27 07](https://user-images.githubusercontent.com/82302520/231447332-66004e33-5e5c-4002-9b5d-83592c4335dd.png)


Seperate Chaining 방식은 Collision을 해결하기 위해 Tree나 LinkedList를 사용하는 방식이다.
- 삽입 : 서로 다른 Key가 같은 해시값을 가지면 LinkedList에 노드를 추가하여 키/값을 저장한다. 시간 복잡도는 O(1)이다.
- 검색 : 기본적으로 O(1)의 시간 복잡도, 최악으로 O(N)의 시간복잡도를 가진다. -> 모든 키의 해시값이 곂치는 상황
- 삭제 : 삭제할 대상을 찾기 위한 시간 복잡도가 함께 고려된다. 기본적으로는 O(1), 최악의 경우에는 O(N)이다.

> Java의 HashMap은 Seperate Chaining을 사용할때 6개 밑으로 내려가면 LinkedList를 사용하고 8개 이상으로 올라가면 Red-Black Tree로 변환한다. 중간값인 7개로 설정하지 않고 2의 차이를 둔 이유는 특정 값을 기준으로 하면 자료 구조의 변경이 너무 자주 일어날 수 있기 때문이다.

## Stack
stack은 LIFO(Last In First Out)의 자료구조이다.
- Push : 시간복잡도 O(1)
- Pop : 시간복잡도 O(1)

## Queue
Queue은 FIFO(First In First Out)의 자료구조이다.
- Push : 시간복잡도 O(1)
- Pop : 시간복잡도 O(1)

- **Queue를 구현하는 방법**
- **Array를 기반으로 구현하는 방법** : 고정된 메모리 공간을 할당하고 시작하기 때문에 enqueue와 dequeue 과정에서 불필요한 메모리 공간이 생긴다. 또한 queue의 크기를 넘어서면 새로운 배열을 할당해줘야 한다. 이를 해결하기 위해 Circular Queue를 사용한다.
- **List를 기반으로 구현하는 방법** : 메모리 공간을 필요할때 생성해서 사용하기 때문에 효율이 좋다.

## Graph
그래프는 노드와 그 노드를 연결하는 간선을 하나로 모아 놓은 자료구조를 일컫는다.

**그래프의 종류**

- 무방향 그래프 vs 방향 그래프
    - 무방향 그래프는 간선을 통해서 양 방향으로 갈 수 있음
    - 방향 그래프는 갈 수 있는 방향이 정해져 있음
- 순환 그래프 vs 비순환 그래프
    - 순환 그래프는 경로 시작 정점과 종료 정점이 동일한 경우
    - 비순환 그래프는 사이클이 없는 그래프
- 연결 그래프 vs 비연결 그래프
    - 연결 그래프는 모든 정점간의 경로가 있음
    - 비연결 그래프는 중간에 단절되어 있음


## Tree

트리는 노드로 이루어진 자료 구조를 말한다. 즉, 그래프의 한 종류라 할 수 있다.
- 사이클이 없는 하나의 연결 그래프
- 방향성이 없는 비순환 그래프의 한 종류

**트리의 구조**

![스크린샷 2023-04-12 오후 8 29 08](https://user-images.githubusercontent.com/82302520/231447404-e3e4835f-fdea-49a4-912d-9c0786d467d3.png)

### 트리의 종류

**이진 탐색 트리**
- 모든 노드 n에 대해서 왼쪽 자식 < N < 오른쪽 자식이 성립하는 트리


**균형 트리**

- 데이터의 삽입 삭제가 일어날때마다 자동으로 리밸런싱을 진행하는 트리

**완전 이진 트리**

![스크린샷 2023-04-12 오후 8 32 07](https://user-images.githubusercontent.com/82302520/231447435-b1511567-1e6f-4fbf-ab5f-cb542ee835a5.png)

- 트리의 몯느 높이에서 노드가 꽉 차 있는 이진 트리
- 리프 노드는 왼쪽부터 다 채워져 있어야 한다.

**전 이진 트리**

![스크린샷 2023-04-12 오후 8 32 34](https://user-images.githubusercontent.com/82302520/231447456-a48a2c61-19a5-48dc-9a6f-2da341442698.png)

- 모든 노드가 0개 또는 2개의 자식 노드를 갖는 트리

**포화 이진 트리**

![스크린샷 2023-04-12 오후 8 32 55](https://user-images.githubusercontent.com/82302520/231447479-2ac6348f-24fb-49e0-a74a-b26d2fc51cd8.png)

- 완전 이진 트리이면서 전 이진트리인 경우를 말한다.

## 그래프와 트리의 차이점
- 사이클 여부 : 그래프에는 사이클이 존재하지만, 트리는 사이클이 없음
- 로트 노드의 존재 : 트리는 루트 노드가 존재하고 나머지 노드들은 모두 하나의 부모 노드를 가진다. 그래프는 루트 노드가 없다.
- 방향성 : 트리는 모든 엣지가 방향성을 갖지만 그래프는 방향성이 있을 수도 없을수도 있다.
- 연결성 : 트리는 루트 노드와 임의의 다른 노드 사이에 경로가 존재한다. 반면, 그래프는 모든 노드가 연결되어 있지 않을 수도 있다.

## Binary Heap

이진 힙은 힙 중에서 가장 널리 쓰이는 형태 중 하나로 이진 트리 형태인 힙이다. 이진 힙은 완전 이진 트리라는 조건을 만족해야 한다.

> 완전 이진 트리 : 모든 레벨의 노드가 채워져 있고, 마지막 레벨은 왼쪽부터 채워져 있는 트리

- 최대 힙 : 가장 값이 큰 노드가 최상단에 있는 힙
- 최소 힙 : 가장 값이 작은 노드가 최상단에 있는 힙

## Red-Black Tree

![스크린샷 2023-04-12 오후 8 09 25](https://user-images.githubusercontent.com/82302520/231447506-791d394c-ab47-4cb5-82c7-d09815ac6f20.png)

레드 블랙 트리는 자가 균현 이진 탐색 트리, 즉 Balanced-Tree라고 할 수 있다.

### Balanced-Tree

일반적인 이진 트리의 경우 보통의 상황에서는 검색 속도가 O(logN)이지만 최악의 상황에서는 검색 속도가 O(N)이 될 수 있다.

![스크린샷 2023-04-12 오후 8 11 13](https://user-images.githubusercontent.com/82302520/231447519-dd6b86b8-856d-42e0-a592-282e79325f75.png)

이런 상황을 방지하기 위해 Balanced-Tree는 노드가 추가되거나 삭제될때마다 좌,우의 높이를 맞추기 위해 Rebalancing을 진행한다.
이를 통해 어떤 상황에서든 O(logN)의 탐색 속도를 보장한다.

> Red-Black Tree의 경우, Java HashMap의 Seperate Chaining 기법을 구현하기 위해 사용된다.

## B+Tree
![스크린샷 2023-04-12 오후 7 59 43](https://user-images.githubusercontent.com/82302520/231447558-5a139f51-8616-4cbe-96ef-9e57260f20fb.png)

- B-tree의 확장 개념으로, 브랜치 노드에 key,value를 담을 수 있는 B-Tree와 달리 브랜치 노드에는 Key만 담아놓는다.
- 리프 노드끼리 LinkedList로 연결되어 있다.

**장점**

- 기존의 B-Tree는 모든 노드에 데이터를 가지고 있었지만, B+Tree는 리프 노드에만 데이터를 가지고 있기에 메모리 효율이 높다. 하나의 페이지에 더 많은 Key을 넣을 수 있고 이는 트리 높이가 낮아지는 효과가 있다.
- 데이터를 풀스캔 할 시, B-Tree는 모든 노드를 다 검색해야 하지만, B+Tree는 리프 노드에서 LinkedList를 통해 선형 검색을 할 수 있다.

> DB를 사용할 경우, 단건 검색도 많지만 범위 검색을 하는 경우가 매우 많다. 이때 B+Tree의 구조가 효율적이라 할 수 있다.

## 요청이 계속 들어오는 서버가 있고 접속 로그를 저장하고 싶다. 어떤 자료구조를 활용하면 좋은가?

https://eoriented.github.io/post/log-structured-storage/
