# OS

## 운영체제
하드웨어를 관리하고, 응용 프로그램과 하드웨어 사이에서 인터페이스 역할을 하며 시스템의 동작을 제어하는 시스템 소프트웨어

![image](https://user-images.githubusercontent.com/59307414/228238854-73d3f415-c9d0-4476-a698-68b026aba641.png)

### 시스템 콜 (System Call)
운영체제가 운영체제 각 기능을 사용할 수 있도록 시스템 콜이라는 명령 또는 함수를 제공
API 내부에는 시스템콜을 호출하는 형태로 만들어지는 경우가 대부분

- 커널 모드(영역)에서만 실행 가능한 기능들이 있다.
- 응용 프로그램이 운영체제 기능을 요청하기 위해서, 운영체제는 시스템 콜을 제공한다.

## 프로세스
- 컴퓨터에서 실행되고 있는 프로그램
    
    * 응용 프로그램 ≠ 프로세스
    
    → 응용 프로그램은 여러 개의 프로세스로 이루어질 수도 있다.
    
- 실행되고 있는 프로그램의 인스턴스
- 프로세스간 독립적
- CPU로부터 메모리 할당

## 스레드
- 프로세스 내에서 실행되는 흐름의 단위
- 프로세스가 할당받은 자원을 이용
- 같은 메모리 공간 공유

![image](https://user-images.githubusercontent.com/59307414/228239208-f178144b-d795-4f8e-a276-40e2fb5cd8d6.png)

## 멀티스레드, 멀티프로세스, 병렬프로그래밍

### 멀티 스레드
하나의 응용 프로그램에서 여러 스레드를 구성해 각 스레드가 하나의 작업을 처리하는 것
스레드들이 공유 메모리를 통해 다수의 작업을 동시에 처리하도록 해줌

(+) 독립적인 프로세스에 비해 공유 메모리만큼의 시간, 자원 손실이 감소 전역 변수와 정적 변수에 대한 자료 공유 가능

(-) 안전성 문제. 하나의 스레드가 데이터 공간 망가뜨리면, 모든 스레드가 작동 불능 상태 (공유 메모리를 갖기 때문)

→ 해결하기 위해서 스레드간 동기화 필요

### 멀티 프로세서 (= 병렬 프로그래밍)
하나의 컴퓨터에 여러 CPU 장착 → 하나 이상의 프로세스들을 동시에 처리(병렬)

(+) 안전성 (메모리 침범 문제를 OS 차원에서 해결)

(-) 각각 독립된 메모리 영역을 갖고 있어, 작업량이 많을수록 오버헤드(Overhead) 발생, Context Switching으로 인한 성능 저하

![image](https://user-images.githubusercontent.com/59307414/228239573-16e00426-a20f-47f4-bb0b-ad96349c1352.png)

## 동기와 비동기 & blocking / non-blocking
- 동기: 함수 A가 함수 B를 호출한 뒤, 함수 B의 리턴값을 계속 확인

    ![image](https://user-images.githubusercontent.com/59307414/228230129-bf385a71-1c65-4380-bba1-d943e98cfbb7.png)


- 비동기: A가 함수 B를 호출할 때 콜백 함수를 함께 전달, B 작업이 완료될 때 콜백함수가 실행 (A는 B 함수의 작업 완료 여부를 신경쓰지 않음)

    ![image](https://user-images.githubusercontent.com/59307414/228230150-f87bad59-65e5-4a98-bf64-667cbf95cf2a.png)

> 동기 vs 비동기 : 호출한 함수의 작업 완료 여부를 확인하느냐

- 블로킹: A 함수가 B 함수를 호출하면, 제어권을 A가 호출한 B 함수에게 전달

    ![image](https://user-images.githubusercontent.com/59307414/228230185-8262f0ab-de39-4fa9-bb9d-e35ead3b9eaa.png)


- 논블로킹: A 함수가 B 함수를 호출해도 제어권은 그대로 A가 가지고 있음

    ![image](https://user-images.githubusercontent.com/59307414/228230232-fd570cb7-020a-4aec-b6b9-44c57f17694b.png)


> 블로킹 vs 논블로킹 : 제어권을 어떻게 처리하느냐

ref. https://velog.io/@nittre/%EB%B8%94%EB%A1%9C%ED%82%B9-Vs.-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%8F%99%EA%B8%B0-Vs.-%EB%B9%84%EB%8F%99%EA%B8%B0

---

> 순서 변경: 프로세스 이해 및 CPU의 활용도를 높이기 위한, 또는 응답 시간을 짧게 가져가기 위한 스케줄링 후 프로세스 동기화 및 이벤트 처리를 학습하는 방향으로

## Context Switching
실행중인 프로세스를 중단하고, 다른 프로세스를 처리하기 위한 과정

- CPU가 이전의 프로세스 상태를 PCB에 보관하고, 또 다른 프로세스의 정보를 PCB에 읽어 레지스터에 적재하는 과정

- 프로세스가 **Ready → Running, Running → Ready, Running → Waiting** 처럼 상태 변경 시 발생

현재 실행중인 프로세스의 상태(Context)를 먼저 저장하고, 다음 프로세스를 동작시켜 작업을 처리한 후에 이전에 저장된 프로세스의 상태를 다시 복구

### PCB(Process Control Block)

#### Process Management

- CPU가 프로세스가 여러개일 때, CPU 스케줄링을 통해 관리하는 것을 말함
- 이때, CPU는 각 프로세스들이 누군지 알아야 관리가 가능함
- 프로세스들의 특징을 갖고있는 것이 바로 **Process Metadata**

#### PCB(Process Control Block)

- **Process Metadata**들을 저장해 놓는 곳
- 한 PCB 안에는 한 프로세스의 정보가 담김

#### PCB가 왜 필요할까
CPU에서는 프로세스의 상태에 따라 교체작업이 이루어진다.

interrupt가 발생해서 할당받은 프로세스가 wating 상태가 되고 다른 프로세스를 running으로 바꿔 올릴 때, 앞으로 다시 수행할 대기 중인 프로세스에 관한 저장 값을 PCB에 저장

#### PCB 관리
Linked List 방식으로 관리. PCB List Head에 PCB들이 생성될 때마다 붙게 된다.

주소값으로 연결이 이루어져 있는 연결리스트이기 때문에 삽입 삭제가 용이함. 즉, 프로세스가 생성되면 해당 PCB가 생성되고 프로세스 완료시 제거됨

## CPU 스케줄링

### 배경

- **배치처리시스템** (Batch Processing)
    
    컴퓨터 프로그램 실행 요청 순서에 따라 순차적으로 프로그램을 실행
    
    → 음악을 들으면서 코딩을 하고 싶다면? →  **멀티프로그래밍**
    
    → 하나의 컴퓨터를 여러 명이 사용하려면? → **시분할시스템**
    

- **멀티 프로그래밍**
    - **멀티 태스킹**
        
        단일 CPU에서, 여러 응용 프로그램이 동시에 실행되는 것처럼 보이도록 하는 시스템
        
    - **멀티 프로세싱**
        
        여러 CPU에 하나의 프로그램을 병렬로 실행해서 실행속도를 극대화시키는 시스템
        

- **시분할시스템**
    
    다중 사용자 지원을 위해 컴퓨터 응답 시간을 최소화하는 시스템
    

### 목적 :

- **CPU의 효율성을 최대한 높이자 (멀티 프로그래밍)**
    
    (오버헤드를 줄이고 사용률을 높이자)
    
- **프로세스 응답 시간을 가능한 짧게 (시분할시스템)**
- **스케줄러 : 프로세스 실행을 관리 (스케줄링을 하는 친구)**

### 선점 / 비선점 스케줄링

- **비선점 (nonpreemptive)**
    - 프로세스 종료 or I/O 등의 이벤트가 있을 때까지 실행 보장 (처리시간 예측 어려움)
    - Ex. FCFS(FIFO), SJF
    - 비선점형 스케쥴러 : 하나의 프로세스가 끝나지 않으면 다른 프로세스는 CPU를 사용할 수 없음
    
- **선점 (preemptive)**
    - OS가 CPU의 사용권을 선점할 수 있는 경우, 강제 회수하는 경우
    - Ex. Priority, RR, Multilevel Queue
    - 선점형 스케쥴러 : 하나의 프로세스가 다른 프로세스 대신에 프로세서(CPU)를 차지할수 있음

### 종류

- 세부 스케줄러 종류는 Notion or https://github.com/wilump-labs/cs/tree/main/os-1#2-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC-%EC%A2%85%EB%A5%98 

## 동기화
작업들 사이에 실행 시기를 맞추는 것

- 프로세스 동기화
- 스레드 동기화

### Critical Section(임계영역)
동일한 자원을 동시에 접근하는 작업(e.g. 공유하는 변수 사용, 동일 파일을 사용하는 등)을 실행하는 코드 영역

### 임계영역 문제 해결 방법

- Mutual Exclusion(상호 배제)
    
    프로세스 P1 이 Critical Section에서 실행중이라면, 다른 프로세스들은 그들이 가진 Critical Section 에서 실행될 수 없다.
    
- Progress(진행)
    
    Critical Section 에서 실행중인 프로세스가 없고, 별도의 동작이 없는 프로세스들만 Critical Section 진입 후보로서 참여될 수 있다.
    
- Bounded Waiting(한정된 대기)
    
    프로세스 P1이 Critical Section 에 진입 신청 후 부터 받아들여질 때가지, 다른 프로세스들이 Critical Section 에 진입하는 횟수는 제한이 있어야 한다.

## 뮤텍스/세마포어
Critical Section(임계 구역)에 대한 접근을 막기 위해 LOCKING 메커니즘이 필요

- Mutex (binary semaphore)
    - 임계구역에 하나의 스레드만 들어갈 수 있음
- Semaphore
    - 임계구역에 여러 스레드가 들어갈 수 있음
    - counter를 두어서 동시에 리소스에 접근 할 수 있는 허용 가능한 스레드 수를 제어

### 상호 배제(Mutual Exclusion) → Mutex
임계 구역을 가진 스레드들의 실행시간이 서로 겹치지 않고 각각 단독으로 실행되게 하는 기술

- **lock** : 현재 임계 구역에 들어갈 권한을 얻어옴 ( 만약 다른 프로세스/스레드가 임계 구역 수행 중이면 종료할 때까지 대기 )
- **unlock** : 현재 임계 구역을 모두 사용했음을 알림. ( 대기 중인 다른 프로세스/스레드가 임계 구역에 진입할 수 있음 )

→ 뮤텍스는 상태가 0, 1로 이진 세마포어로 부르기도 함.

### 세마포어(Semaphore)
멀티프로그래밍 환경에서 공유 자원에 대한 접근을 제한하는 방법

- 공유된 자원에 여러 프로세스가 동시에 접근하면서 문제가 발생할 수 있다.

- 이 때 공유된 자원의 데이터는 한 번에 하나의 프로세스만 접근할 수 있도록 제한을 둬야 한다. → **세마포어**

- **세마포어 P, V 연산**
    
    **P** : 임계 구역 들어가기 전에 수행 ( 프로세스 진입 여부를 자원의 개수(S)를 통해 결정)
    
    **V** : 임계 구역에서 나올 때 수행 ( 자원 반납 알림, 대기 중인 프로세스를 깨우는 신호 )

## 교착 상태(Deadlock)의 개념과 조건
일종의 무한 대기 상태
    
두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에, 다음 단계로 진행하지 못하는 상태

- 현재 서로 원하는 자원이 상대방에 할당되어 있어서 두 프로세스는 무한정 wait 상태에 빠짐

### DeadLock 발생 조건
→ 4가지 모두 성립해야 DeadLock 발생 (하나라도 성립하지 않으면 문제 해결 가능)

1) **상호 배제(Mutual exclusion)**

- 자원은 한번에 한 프로세스만 사용할 수 있음

2) **점유 대기(Hold and wait)**

- 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 함

3) **비선점(No preemption)**

- 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음

4) **순환 대기(Circular wait)**

- 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 함

### DeadLock 처리

1) **예방(prevention)**

교착 상태 발생 조건 중 하나를 제거하면서 해결한다 (자원 낭비 엄청 심함)

- 상호배제 부정 : 여러 프로세스가 공유 자원 사용
- 점유대기 부정 : 프로세스 실행전 모든 자원을 할당
- 비선점 부정 : 자원 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원 반납
- 순환대기 부정 : 자원에 고유번호 할당 후 순서대로 자원 요구

2) **회피(avoidance)**

교착 상태 발생 시 피해나가는 방법

- 은행원 알고리즘(Banker's Algorithm)은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래함
- 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 사전에 검사하여 교착 상태 회피
- 안정 상태면 자원 할당, 아니면 다른 프로세스들이 자원 해지까지 대기

3) **탐지(Detection)**

- 자원 할당 그래프를 통해 교착 상태를 탐지함
- 자원 요청 시, 탐지 알고리즘을 실행시켜 그에 대한 오버헤드 발생함

4) **회복(Recovery)**

교착 상태 일으킨 프로세스를 종료하거나, 할당된 자원을 해제시켜 회복시키는 방법

- 프로세스 종료 방법
    - 교착 상태의 프로세스를 모두 중지
    - 교착 상태가 제거될 때까지 하나씩 프로세스 중지
- 자원 선점 방법
    - 교착 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에게 할당 (해당 프로세스 일시정지 시킴)
    - 우선 순위가 낮은 프로세스나 수행 횟수 적은 프로세스 위주로 프로세스 자원 선점


## 기아상태 (Starvation)

- 특정 프로세스의 우선순위가 낮아서 원하는 자원을 계속 할당 받지 못하는 상태
- 교착상태와 기아상태
- 교착상태는 여러 프로세스가 동일 자원 점유를 요청할 때 발생
- 기아상태는 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때, 특정 프로세스는 영원히 자원 할당이 안되는 경우를 주로 의미함

### 기아상태 처리

- 우선순위 변경
    - 프로세스 우선순위를 수시로 변경해서, 각 프로세스가 높은 우선순위를 가질 기회주기
    - 오래 기다린 프로세스의 우선순위를 높여주기
    - 우선순위가 아닌, 요청 순서대로 처리하는 FIFO 기반 요청큐 사용

## 경쟁상태 (Race Condition)

- 공유 자원에 대해 여러 프로세스가 동시에 접근할 때, 결과값에 영향을 줄 수 있는 상태

### 발생 조건

1) ****커널 작업을 수행하는 중에 인터럽트 발생****

◦ 문제점 : 커널모드에서 데이터를 로드하여 작업을 수행하다가 인터럽트가 발생하여 같은 데이터를 조작하는 경우

◦ 해결법 : 커널모드에서 작업을 수행하는 동안, 인터럽트를 disable 시켜 CPU 제어권을 가져가지 못하도록 한다.

2) ****프로세스가 'System Call'을 하여 커널 모드로 진입하여 작업을 수행하는 도중 문맥 교환이 발생할 때****
    ◦ 문제점 : 프로세스1이 커널모드에서 데이터를 조작하는 도중, 시간이 초과되어 CPU 제어권이 프로세스2로 넘어가 같은 데이터를 조작하는 경우 ( 프로세스2가 작업에 반영되지 않음 )
    ◦ 해결법 : 프로세스가 커널모드에서 작업을 하는 경우 시간이 초과되어도 CPU 제어권이 다른 프로세스에게 넘어가지 않도록 함

3) ****멀티 프로세서 환경에서 공유 메모리 내의 커널 데이터에 접근할 때****
    ◦ 문제점 : 멀티 프로세서 환경에서 2개의 CPU가 동시에 커널 내부의 공유 데이터에 접근하여 조작하는 경우
    ◦ 해결법 : 커널 내부에 있는 각 공유 데이터에 접근할 때마다, 그 데이터에 대한 lock/unlock을 하는 방법

## 페이지 교체 알고리즘

`페이지 폴트` → `새로운 페이지 할당` → `현재 할당된 페이지 중 어떤 것을 교체할지 결정`

: OS가 특정 페이지를 물리 메모리에 올려야 하는데, 물리 메모리가 다 차 있다면?

→  기존 페이지 중 하나를 물리 메모리에서 저장 매체로 내리고(저장)

새로운 페이지를 해당 물리 메모리 공간에 올림 

### 1. FIFO

- **가장 먼저 들어온 페이지를 교체**

### 2. OPT(OPTimal Replacement Algorithm)

- **앞으로 가장 오랫동안 사용하지 않을 페이지를 교체**
- 일반 OS에서는 구현 불가

### 3. LRU(Least Recently Used)

- **가장 오래 전에 사용된 페이지를 교체**
- OPT가 미래 예측인 반면, LRU는 과거를 기반으로 판단

### 4. LFU(Least Frequently Used)

- **가장 적게 사용된 페이지를 교체**

### 5. MFU(Most Frequently Used)

- **가장 많이 사용된 페이지를 교체**