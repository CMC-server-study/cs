# DB

### 인덱스


<details>
<summary>답변</summary>
<div markdown="1">

## 인덱스

### B-Tree를 다른 자료구조 대신 DB 인덱스로 선택한 이유

---

B-Tree vs Red-Black Tree

- 공통점
    - red-black tree와 b-tree 모두 balanced tree로써 **항상 좌우 균형이 유지**되기 때문에 O(logN)의 탐색 시간 복잡도가 유지된다.
    - 항상 균형을 맞추는 과정이 수반되기 때문에 추가 삭제 수정에 시간이 더 소요된다.

- 차이점
    - red-black tree는 하나의 노드에 하나의 데이터만 들어갈 수 있다.
    - B-Tree의 경우 하나의 노드에 여러 데이터가 들어갈 수 있다. MySQL 에서는 하나의 페이지에 인덱스 키가 최대 585개 들어갈 수 있다. 따라서 자식 노드를 그만큼 가질 수 있는 것이다.


하나의 노드에 들어가는 데이터 수가 많다는 건, 탐색을 위한 시간 복잡도가 줄어든다는 의미이다.

하나의 노드 내의 데이터들은 물리 메모리 상의 연속적인 배열로 연결되어 있다. 이미 주소값이 다 계산되어 있기 때문에 따로 탐색에 시간이 들지 않는다. 즉, 랜덤 엑세스가 아니라 순차 엑세스로 조회할 수 있다.

하지만 red-black-tree의 경우 다른 데이터를 참조하기 위해 항상 참조 포인터를 사용해서 이동해야 한다. 주소값을 계산하는 과정은 CPU Intensive한 활동이기 때문에 비용이 많이 든다.

❗️Red-Black Tree와 B-Tree의 시간복잡도는 O(logN)으로 동일하다. 하지만 이는 이론적인 수치의 동일함임. 실제로는 탐색에 있어서 시간 차이가 많이 난다!

### B-Tree vs Array

Array는 조회에 있어서 O(1)의 시간 복잡도를 가진다. 또한 데이터의 정렬 또한 가능하다.

- 배열을 인덱스 자료구조로 사용할 수 없는 이유
    - 수정 삭제 추가에 있어서 O(n)의 비용이 들어감 → 쓰기 성능이 너무 낭비임
    - 반면 B-tree는 쓰기 시간 복잡도도 O(logN)으로 유지된다.

### B-Tree vs Linked List

링크드 리스트는 쓰기 작업에 있어서 소요되는 시간복잡도가 매우 적다.

하지만, 탐색에 있어서 랜덤 엑세스가 아니라 Head 부터 순차적으로 접근해야 한다. 탐색의 시간복잡도 O(n).

### B-Tree vs Hash Index


- Hash Index의 장점
    - 동등 비교를 할 때 시간 복잡도가 O(1)이다
- Hash Index의 단점
    - 정렬이 되지 않기 때문에 범위 검색을 할 수 없다.
    - Like% 검색을 통한 최적화가 불가능 하다.

### Index vs Sorted List

데이터베이스의 Index는 SortedList와 같은 원리이다.

- 데이터를 넣을때마다 정렬을 해줘야 하기 때문에 쓰기 속도가 느리다.
- 쓰기 성능을 희생하고 탐색 속도를 높혔다.


### Real MySQL 인덱스 정리

---

b-tree index의 기본 구조

- 가장 상단의 루트 노드
- 가장 하단의 리프 노드
- 중간의 브랜치 노드

리프 노드에는 실제 데이터 레코드에 대한 주소값이 들어간다.

클러스터링 인덱스를 사용하는 InnoDB의 경우 세컨더리 인덱스의 리프 노드에 데이터 레코드 ROWID 말고 PK값이 들어간다.

이때 데이터 파일 내부에서는 바로 데이터 레코드로 들어가는게 아니라, 다시 프라이머리 키를 기준으로 한, 전체 인덱스가 시작된다.

❗️즉, 세컨더리 인덱스를 쓰면 인덱스를 총 2번 타고, 바로 PK로 조회하면 1번 탄다.

### 인덱스 추가 비용

- 만약 테이블에 인덱스가 3개라면, 레코드 하나 추가될때, 결국 그 인덱스 3개를 다 추가해야 한다.
- 레코드를 추가하는 비용이 1, 인덱스에 키값 추가하는 비용이 1.5 라고 예측 시, 인덱스 3개라면 3*1.5 + 1, 총 5.5의 비용이 드는 것이다.

### 인덱스 추가

- innodb 이외의 엔진의 경우, 레코드 추가 시 즉시 인덱스의 키값도 변경
- innodb는 유니크 인덱스나 프라이머리 인덱스의 경우에는 중복 체크를 위해 즉시 반영,
    - 세컨더리 인덱스의 인덱스 키 추가는 잠시 지연시킬 수 있다. (체인지 버퍼에 버퍼링 해놓음)

### 인덱스 삭제

해당 키 값이 저장된 리프 노드 찾아가서 삭제 마크 한다. 이때 삭제 마킹 작업은 디스크 쓰기 필요함

- 체인지 버퍼에 버퍼링 해서 지연 처리 가능

### 인덱스 변경

- 인덱스 키값의 변경 작업은 선 delete 후 Insert의 2개의 과정으로 이뤄진다.
- 키값에 따라 소속되는 리프 노드가 달라지기 때문이다. innodb에서는 전부 지연 처리 가능함


### 중요

레코드를 update 하거나 delete할 경우, 변경할 레코드를 찾기 위해 인덱스를 탄다.

이때 InnoDB의 경우 변경에 사용한 인덱스에 대해 전부 락을 걸고 (Ex update 절에 포함된 where 조건 인덱스)

update와 delete의 경우에도 그 변경할 레코드를 찾기 위해 인덱스를 탄다.

이때 innodb는 변경을 위해 검색한 모든 인덱스에 대해 락을 건 후, 해당하는 레코드 전체에 잠금을 건다.

인덱스 잘못 걸면 잘못하면 모든 레코드를 잠글수도 있음

### 결론 

- 인덱스는 쓰기 작업의 성능을 희생하고 조회 성능을 극대화 시키는 방법이다. 읽기 요청과 쓰기 요청 비율이 8대2 정도인 OLTP 환경에서는 인덱스를 사용하는게 적합

### 좋은 인덱스 기준

카더널리티 : 높다 → 포함된 요소의 종류의 수

- ex. 성별은 카더널리티가 2

선택도 : 낮다 → 총 개수중 특정 요소의 비율
- ex. 총 10명 중에 여자가 2명이면 선택도는 2 / 10 -> 0.2  

선택도가 낮아야 쓸모없는 값을 조회하는 비율이 줄어든다.
- ex. 인덱스를 통해 2000건중 1000건을 필터링 하는 경우(1)과 2000건중 100건을 필터링하는 경우(2)가 있을 때, 실제 필요한 데이터가 1건이라면 경우 1은 999건의 불필요한 디스크 IO가 생겼고 경우 2는 99건의 불필요한 디스크 IO가 생긴다


- 쿼리의 효율성 지표 → 얼마나 쓸모없는 값들을 조회하지 않았냐 → 다 디스크 I/O와 관련있기 때문!


❗️일반적으로 인덱스를 통해 읽는 작업이 테이블에서 직접 데이터 1건 가져오는것보다 4~5배 정도 비용이 더 든다고 함.

따라서 효율적이지 않은 방법은 풀 테이블 스캔을 하는게 낫고, 옵티마이져 단에서도 무시한다.

### MySQL의 인덱스 사용 방법

**인덱스 레인지 스캔**

검색해야 할 인덱스의 범위가 결정됐을때 사용하는 인덱스

1. 인덱스를 통해서 루트 노드부터 리프 노드까지 검색해서 시작점 레코드를 찾는다.
2. 거기서 부터 쭉 스캔을 진행하고, 리프노드의 끝까지 읽으면 다음 노드까지 링크를 통해 이동한다.
    - 쭉 스캔이 가능한 이유 : B+Tree 구조라서 리프 노드가 링크드 리스트로 연결됨

쭉 스캔할때 실제 데이터 파일에서 나머지 정보를 읽어오는 과정을 레코드 한건한건 단위로 I/O가 발생한다.

이 때문에 인덱스를 통해 레코드를 읽는 과정이 비용이 많다고 하고, 가지고 와야하는 데이터가 전체의 25프로 정도가 넘으면 오히려 테이블 스캔이 유리하다.

**인덱스 풀 스캔**

쿼리 조건절에 사용된 컬럼이 인덱스의 첫번째 컬럼이 아니면 인덱스 풀 스캔이 걸린다.

- 인덱스는 (a,b,c) 인데 조건에는 b나 c 사용한경우.

❗️위의 2개는 타이트 인덱스 스캔

**루스 인덱스 스캔**

만약 2개 이상의 컬럼이 인덱스로 묶여있다면, 모든 인덱스에 대해서 체크하지 않아도 될 수도 있다. 예를 들어서 1번 컬럼과 2번 컬럼 조합에서 2번 컬럼은 최소값만 구하면 된다면, 첫번째 인덱스만 체크 후, 다음 1번 컬럼 값으로 넘어가도 된다.

**인덱스 스킵 스캔**

실행 계획 상에서 type이 index인건 인덱스 풀 스캔을 말한다.
만약 (a,b) 인덱스에서 b만 가지고 쿼리를 짜더라도 인덱스 스킵 스캔 활성화하면 옵티마이져가 자동적으로 동등 조건 넣어서 스킵스캔 해줌

- 스킵 스캔이 가능한 조건
    - 선행 컬럼의 유니크 값이 적어야함 즉, 성별 같이 카더널리티가 떨어져야 한다.
        - 만약 카더널리티가 너무 높으면 동등 비교를 해야하는게 너무 많아짐
    - 무조건 커버링 인덱스일때 사용 가능, 아니면 테이블 풀 스캔 해버림


</div>
</details>

### 트랜잭션

<details>
<summary>답변</summary>
<div markdown="1">

### 트랜잭션 특징 (ACID)

원자성

- 트랜잭션 내에서 실행한 모든 작업들은 하나의 작업인 것처럼 모두 성공하거나 모두 실패해야 한다. 부분 성공이나 부분 실패는 없다.

격리성

- 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 해야한다. 격리성은 동시성과 관련된 성능 이슈와 직결되어 있다.

지속성

- 한번 성공한 트랜잭션은 그 결과가 항상 기록되어야 한다. 보통 로그로써 디스크에 기록된다. 중간에 시스템 문제가 생겨서 DB가 다운되더라도 로그를 사용해서 원래대로 복구할 수 있어야 한다.

일관성

- 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다. ex> 무결성 제약 조건

### 트랜잭션 격리 수준

---

- Read Uncommited
- Read Commited
- Repeatable read
- serializable

<img width="759" alt="스크린샷 2023-02-22 오후 9 34 11" src="https://user-images.githubusercontent.com/82302520/220623692-af2ef968-8d2c-43f2-b5cf-e7dbc7ae4f2b.png">



### Read Uncommited


트랜잭션 1이 데이터를 수정 후, 아직 커밋하지 않았더라도 트랜잭션 2가 그 데이터를 조회할 수 있다.

- 단점 : 만약 트랜잭션 1이 롤백된다면 트랜잭션 2가 조회한 데이터는 의미가 없어지고 데이터 정합성에 문제가 생긴다. 이 현상을 `dirty read` 라고 한다.

이 격리 수준은 실제로 사용할 수 없는 수준이기에 격리 수준으로 분류되지도 않음 무조건 피해야 한다.


### Read Committed

트랜잭션 1이 특정 데이터를 수정하면 즉시 DB에는 반영이 되지만, 이전 데이터는 언두 영역에 복구용으로 저장된다. 만약 트랜잭션 1이 아직 커밋하지 않은 상태에서 트랜잭션 2가 데이터를 조회한다면 실제 db가 아닌 언두 영역의 데이터를 조회한다.

언두 영역은 트랜잭션이 끝난 후 바로 제거되는 것이 아니라 일정 시간이 지난 후, 더이상 쓸 일이 없다고 판단되면 그때 삭제된다.

이때 언두 영역에 따로 이전 버전을 저장함으로써 dirty read를 방지하는 방식을 `MVCC`라고 한다.

- 장점 : dirty read는 발생하지 않는다.

- 단점 : non repeatable read가 발생한다.

→ non-repeatable read

트랜잭션 2가 트랜잭션 시작 후 특정 데이터를 조회한다. 이때 트랜잭션 1이 데이터를 수정하고 커밋을 한다. 그 다음에 트랜잭션 2가 내부적으로 같은 데이터를 호출하면 이번에는 수정된 데이터가 조회된다. 언두 영역도 의미가 없는게 이미 데이터를 수정하고 커밋을 했기 때문에 db에 반영된 데이터를 가지고 온다.

### Repeatable read

mysql의 innodb에서 사용하는 격리 수준

dirty read와 non-repeatable read가 발생하는 건 막아주지만, phantom read는 못 막는다.

트랜잭션 id를 트랜잭션마다 부여한다. 이때 자신의 트랜잭션 id보다 더 작은 값의 레코드만 사용한다. 만약에 트랜잭션을 시작한후 데이터를 조회할때 자신의 트랜잭션 아이디보다 더 큰 트랜잭션 id로 수정된 값이 있으면 무시하고 언두 영역에 있는걸 사용한다. read commited와 repeatable read의 차이점은 몇번째 버전까지 타고 내려가는지 여부이다. read commited가 하나의 버전, repeatable은 여러 버전!


추가

- [갱신손실](https://github.com/jemlog/tech_study/blob/master/db/transaction/%EA%B0%B1%EC%8B%A0%EC%86%90%EC%8B%A4.md)
</div>
</details>

### join

<details>
<summary>답변</summary>
<div markdown="1">

<img width="669" alt="스크린샷 2023-02-20 오전 10 49 52" src="https://user-images.githubusercontent.com/82302520/220623770-f26b38cb-e91a-43a3-9863-90854215aa19.png">


inner join

- 드라이빙 테이블과 드리븐 테이블 공통으로 존재하는 데이터가 있을때만 조인한다

left outer join

- 드라이빙 테이블 쪽의 모든 데이터를 포함한 조인을 진행한다. null 값이 많아질 수있음

right outer join

- 드리븐 테이블 쪽의 모든 데이터를 포함한 조인을 진행한다.

full outer join

- 양쪽의 모든 데이터를 보여준다

cross join

- 나올 수 있는 모든 경우의 수를 곱한다. N * M 의 개수가 나온다고 할 수 있다.

</div>
</details>


### Key

<details>
<summary>답변</summary>
<div markdown="1">

슈퍼키
    
- 하나의 레코드를 유일하게 식별할 수 있는 속성들의 집합, 하나 또는 여러개의 속성들이 묶일 수 있다.


후보키
- 슈퍼키들 중 최소한의 속성을 가지고 있는 키를 말한다.

기본키
- 후보키들 중 선택된 하나의 키
- not null 해야 하고 unique 해야 한다.

외래키
- 다른 테이블의 프라이머리 키와 연결되는 테이블의 컬럼

대체키
- 프라이머리 키 이외의 후보키들을 말함

복합키
- 테이블에서 최소 조건인 하나의 컬럼만으로 기본키를 만들 수 없을때 2개 이상의 컬럼을 합쳐서 만들 수 있는 후보키

### 클러스터링 키 (MySQL InnoDB)


클러스터링 인덱스를 사용할 시의 장단점


- 장점
    - PK로 검색할 때 처리가 매우 빠름
    - 연속되는 PK로 조회할 경우 랜덤 I/O가 아닌 순차 I/O를 사용하여 처리 속도가 더욱 빠름
    - 인덱스가 PK값을 가지므로 인덱스로 PK 값만 조회하는 경우 효율적으로 처리될 수 있음(=커버링 인덱스)
- 단점
    - 모든 인덱스가 PK에 의존하므로 PK 값이 클 경우 전체적으로 인덱스의 크기가 커지고, 페이지 양이 많아짐
    - 인덱스를 통해 검색할 때 PK로 다시 한번 검색해야 하므로 처리 성능이 느림 → 세컨더리 인덱스 사용 시
    - INSERT 시에 PK에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림
    - PK를 변경할 때 레코드를 DELETE 및 INSERT 해야 하므로 처리 성능이 느림
    - PK를 변경하면 레코드의 물리적인 저장 위치가 변하기 때문에 인덱스도 수정이 필요함



클러스터링 키 지정

1. 기본적으로 PK를 클러스터링 키로 선택함
2. PK가 없다면 NOT NULL 옵션의 유니크 인덱스 중에서 첫 번째 인덱스를 클러스터링 키로 선택함
3. 후보군이 없다면 내부적으로 자동 증가 유니크 컬럼을 추가한 후 클러스터링 키로 선택함

❗️내부적인 자동 증가 컬럼은 사용자가 사용할 수 없으므로 효율이 떨어진다. PK는 꼭 따로 생성해주자.


### 기본키로 자연키 사용 vs 대체 키 사용


- 대체키는 보통 autoincrement로 숫자 사용
- 자연키는 문자열을 보통 사용 Ex. 주민등록번호

이때 문자열을 사용하면 PK를 비대하게 만들어 성능에 좋지 못하다. PK의 크기는 작을수록 좋으며, 원시 타입일수록 좋다. 보통 문자열이 숫자보다 처리 속도도 느리다.

자연키를 사용할때의 단점

- 테이블 구조가 복잡해짐
    - 자연키를 PK로 사용할 때, 1개의 컬럼 만으로 PK를 구성하지 못하고 복합키로 설정해줘야 하는 경우도 상당히 많다. 대체 키를 사용하면 테이블 구조가 단순해진다

대체키를 사용할때의 장점
- 무결성 검사를 DB로 위임 가능
    - 키의 생성 및 관리를 완전히 데이터베이스에 위임, 자연키를 사용하는건 키의 유효성 검사와 무결성 검사를 개발자가 직접 해줘야 한다.

</div>
</details>


### 정규화

<details>
<summary>답변</summary>
<div markdown="1">

정규화

- 테이블간의 중복된 데이터를 허용하지 않기 위해 테이블을 분해하는 작업

제 1 정규화

- 테이블의 칼럼이 원자값을 갖도록 테이블을 분해

![스크린샷 2023-02-20 오전 10 06 27](https://user-images.githubusercontent.com/82302520/220623981-0e3f3268-36a7-4771-85d4-8d76dc792ba6.png)


제 2 정규화

- 완전 함수 종속을 만족하도록 테이블을 분해한다

    - 완전 함수 종속 : 기본키의 부분집합이 결정자가 되서는 안된다
    
![스크린샷 2023-02-20 오전 10 07 50](https://user-images.githubusercontent.com/82302520/220624070-bff99a7e-2eb3-449a-b970-904c84b57e95.png)
![스크린샷 2023-02-20 오전 10 07 56](https://user-images.githubusercontent.com/82302520/220624075-bf481a8e-475b-4092-95ae-00eb986ab264.png)


제 3 정규화

- 이행적 종속을 없애도록 테이블을 분해하는 것
![스크린샷 2023-02-20 오전 10 15 37](https://user-images.githubusercontent.com/82302520/220624115-738aec00-bd0d-43b9-ad5e-a23dc685bbe3.png)
![스크린샷 2023-02-20 오전 10 15 47](https://user-images.githubusercontent.com/82302520/220624121-d46d8e40-b6f2-426c-86c0-451d57e7e49b.png)

</div>
</details>

### RDBMS vs NoSQL

<details>
<summary>답변</summary>
<div markdown="1">

### NoSQL의 특징

장점
- 유연하고 자유로운 데이터 구조를 가지고 있으므로 스펙 변화가 잦은 서비스에 적합함
- 복잡한 트랜잭션이나 조인이 없기에 수평적 확장에 용이하다
- MongoDB 같은 문서 데이터베이스의 경우 풍부한 인덱스 사용 가능하다

단점
- 데이터의 중복이 있을 수 있다
- 데이터의 중복으로 인해 데이터 수정 작업 시 변경해야 하는 부분이 많다
- 명확한 데이터 구조가 필요한 경우에는 사용하기 힘들다

사용하면 좋은 경우
- 정확한 데이터 구조가 정해지지 않은 경우
- Update가 자주 일어나지 않고 조회가 대부분인 경우
- 데이터 양이 많아서 scale out이 필요할 예정인 경우

### RDBMS의 특징

장점
- 데이터의 중복을 허용하지 않기 때문에 수정 작업에 용이하다
- 명확한 데이터 구조를 보장한다

단점
- 시스템이 커지면 Join문이 많은 복잡한 쿼리가 필요함
- 복잡한 트랜잭션과 Join으로 인해 수평적 확장에 불리하다
- 데이터 구조가 유연하지 못해서 스펙 변화가 잦은 서비스에 불리함

사용하면 좋은 경우
- 데이터 수정 작업이 빈번한 경우
- 정확한 데이터 정합성이 필요한 서비스일 경우


### NoSQL 중 MongoDB의 특징

- 스키마리스의 구조 덕분에 데이터 구조 변경 및 스펙 변화에 자유롭다
- 리치 인덱스를 제공한다. 인덱스 기능이 풍부하고 인덱스 추가는 백그라운드로 실행 가능하다.
- 고가용성과 확장성이 보장된다.
- MongoDB에서 데이터를 범위 검색할때, 중간에 쓰기 배타 락을 얻은 요소가 있으면 읽기가 지연된다. -> MongoDB 5.0 부터는 Lock-Free Read Operation을 지원한다.
- Redis와 비교했을때는 디스크 I/O가 발생하기 때문에 레디스보다 2배 이상 느린 속도를 보여준다.


아래는 NoSQL의 특징과 운영 시 만날 수 있는 문제점에 대해 잘 설명해놓은 글입니다

[LINE 알림 센터의 메인 스토리지를 Redis에서 MongoDB로 전환하기](https://engineering.linecorp.com/ko/blog/LINE-integrated-notification-center-from-redis-to-mongodb)
</div>
</details>

### join 연산 속도

<details>
<summary>답변</summary>
<div markdown="1">

join 조건에 들어가는 컬럼에 모두 인덱스가 걸려있으면 조인은 네스티드 루프 조인 형태로 동작한다.

- join에서 드라이빙 테이블은 순차 검색 
- 조건에 일치하는 드리븐 테이블은 드라이빙 테이블의 레코드 건수 만큼 검색

join 조건에 들어가는 컬럼에 인덱스가 걸려 있지 않다면 드라이빙 테이블의 레코드 건수 만큼 드리븐 테이블 풀 테이블 스캔을 해야 한다. -> 속도 매우 느려짐

- ex> 드라이빙 테이블의 조인 조건에 맞는 레코드 개수가 1000개 일때, 조건에 맞는 드리븐 테이블의 레코드를 찾기 위해서는 1000번의 드리븐 테이블 풀 테이블 스캔 필요함

MySQL에서는 네스티드 루프 조인으로 실행할 수 없을 시 대체제로 해시 조인을 사용한다.


</div>
</details>

### 교착상태

<details>
<summary>답변</summary>
<div markdown="1">

- 하나의 트랜잭션이 락을 획득한채로 장애가 발생해서 다른 트랜잭션들이 락을 회수하지 못하는 상태
- 각각의 트랜잭션이 락을 소유한채로 서로의 락을 획득하기를 대기하는 상태

</div>
</details>

### Statement, PreparedStatement

<details>
<summary>답변</summary>
<div markdown="1">

SQL의 기본 실행 과정


일반적으로 쿼리는 3가지 과정을 거쳐서 실행된다
1. 쿼리 구문 분석
2. 컴파일
3. 실행

- Statement의 경우 매번 쿼리를 실행할때마다 위의 3가지 과정을 진행
- PreparedStatement의 경우 객체를 생성하는 시점에 쿼리 구문 분석과 컴파일을 하고 커맨드 객체를 만듬
  - 내부에 있는 캐시에 SQL 문자열을 키로 커맨드 객체를 밸류로 해서 저장한다. 쿼리를 실행하는 execute 실행 시, 캐시에서 커맨드 객체를 꺼내서 사용한다.
  
- 이미 컴파일이 된걸 사용하기 때문에 바인딩 변수에 특정 문자열을 넣어도 SQL 구문으로써 의미가 있는게 아니라 단순 문자열로 처리된다.



```java
    @Override
    public PreparedStatement prepareStatement(String sql) throws SQLException {
        try {
            int id = getNextId(TraceObject.PREPARED_STATEMENT);
            if (isDebugEnabled()) {
                debugCodeAssign("PreparedStatement", TraceObject.PREPARED_STATEMENT, id,
                        "prepareStatement(" + quote(sql) + ')');
            }
            checkClosed();
            sql = translateSQL(sql); 
            // PrepareStatement 생성
            return new JdbcPreparedStatement(this, sql, id, ResultSet.TYPE_FORWARD_ONLY,
                    Constants.DEFAULT_RESULT_SET_CONCURRENCY, null);
        } catch (Exception e) {
            throw logAndConvert(e);
        }
    }

```

결론 : 쿼리 구문의 캐싱을 통한 빠른 쿼리 사용과 보안 이슈 방지를 위해 preparedStatement를 사용하자

</div>
</details>

### ORM

<details>
<summary>답변</summary>
<div markdown="1">

SQL Mapper

장점
- JDBC를 사용할 때  발생하는 불편함을 줄일 수 있다.
- SQL이 비즈니스 로직과 분리되어 유지보수가 용이하다.
- 세부적인 SQL 변경시 편리하다
- 기존에 SQL문법을 그대로 적용할 수 있어 새로운 기술을 학습하지 않아도 된다.


단점
- DBMS 별로 SQL 문법이 다르다.
- 개발자가 직접 SQL문을 작성해야 한다.
- DBMS 변경시 SQL문을 재사용하기 어렵다.
- 객체와 테이블간 패러다임 불일치가 발생한다.

ORM 

장점
- 개발자가 SQL문을 직접 작성하지 않아도 된다.
- SQL문이 아닌 클래스의 메서드를 통해 데이터에비스를 조작할 수 있다.
- DBMS에 종속적이지 않다.

단점
- 직접 SQL을 작성하는 것보다 성능이 떨어질 수 있다.
- 사용하기 위해서는 ORM 기술을 학습해야 하는 러닝커브가 존재한다.
- 메서들 호출로 DB 데이터를 조작하기 때문에 세밀함이 떨어진다.
- N+1 문제가 발생할 수 있다. 
</div>
</details>

### JDBC

<details>
<summary>답변</summary>
<div markdown="1">

JDBC는 자바에서 데이터베이스에 접속할 수 있도록 하는 자바 API이다. 

서버와 DB가 커넥션을 맺는 구체적인 방법은 DB 벤더마다 모두 다르기 때문에 이를 표준화된 인터페이스로 만든게 JDBC이다

<img width="837" alt="스크린샷 2023-02-22 오후 9 21 35" src="https://user-images.githubusercontent.com/82302520/220623882-d6d520d2-f63a-4e9b-8a6d-b9142dae07ac.png">


</div>
</details>

### 옵티마이져, 실행 계획

<details>
<summary>답변</summary>
<div markdown="1">

실행 계획 

- 클라이언트가 요청한 쿼리에 대해서 옵티마이져가 판단한 최적화된 쿼리 실행 방식
- explain 명령으르 통해 사용할 수 있다.

옵티마이져

SQL문을 실행하기 전에 비용 기반으로 다양한 최적의 실행계획을 수립하는 도구

옵티마이져 종류
- 비용 기반 옵티마이져
- 규칙 기반 옵티마이저

사용자가 지정한 인덱스를 실제로 사용할지, 쿼리를 실행함에 있어서 별도의 메모리를 사용할지 등의 최적화를 계산한다.

Ex> 

- order by 정렬을 처리하는 방법 선택(file sort, temporary table 사용 등등)
- group by를 처리하는 방법 선택
- 조인 방법 선택

</div>
</details>


### 단일키 vs 복합키

<details>
<summary>답변</summary>
<div markdown="1">

단일키 : 컬럼 1개를 key로 사용

복합키 : 컬럼 2개 이상을 조합하여 후보키로 사용

</div>
</details>

### 복제
<details>
<summary>답변</summary>
<div markdown="1">

데이터베이스의 고가용성과 OLTP 환경에서 읽기 트래픽 처리를 위해 복제본을 운영하는 것

마스터-슬레이브 (리더-팔로워) 형태로 운용하면서 마스터는 쓰기 트래픽만 처리하고 읽기 트래픽은 다수의 슬레이브가 처리

- OLTP 환경에서 쓰기와 읽기의 비율이 2대 8정도이기에 읽기 전용 레플리카의 확보 필요

마스터 서버와 레플리카 서버의 데이터 동기화가 관건

- 데이터 정합성의 중요도와 응답 속도의 트레이드오프에 따라 레플리카 노드간의 데이터 일관성 보장 수준이 달라짐

- 현실에서 레플리카 복제를 동기 처리 하는 것은 불가능하다. 동기 처리는 마스터가 레플리카의 복제가 완료될때까지 어떤 쓰기 요청도 처리하지 못한다. 만약 하나의 레플리카 노드가 장애로 다운된다면, 복구가 될때까지 마스터는 쓰기 요청을 지연시켜야 한다.

현실의 복제는 비동기로 처리된다고 할 수 있다.

CAP 이론
1. 일관성(Consistency)

   일관성은 동시성 또는 동일성이라고도 하며 다중 클라이언트에서 같은 시간에 조회하는 데이터는 항상 동일한 데이터임을 보증하는 것을 의미한다. 

   


2. 가용성(Availability)
   
    가용성이란 모든 클라이언트의 읽기와 쓰기 요청에 대하여 항상 응답이 가능해야 함을 보증하는 것이며 내고장성이라고도 한다. 내고장성을 가진 NoSQL 은 클러스터 내에서 몇 개의 노드가 망가지더라도 정상적인 서비스가 가능하다.



3. 네트워크 분할 허용성(Partition tolerance)

   분할 허용성이란 지역적으로 분할된 네트워크 환경에서 동작하는 시스템에서 두 지역 간의 네트워크가 단절되거나 네트워크 데이터의 유실이 일어나더라도 각 지역 내의 시스템은 정상적으로 동작해야 함을 의미한다.


CAP 원칙 중 3가지 조건을 모든 만족 시키는 분산 시스템은 만들 수 없다. 두 가지 속성씩 만족시켜야 한다.

- CP (Consistency & Partition Tolerance) : 어떤 상황에서도 안정적으로 시스템은 운영되지만 Consistency 가 보장되지 않는다면 Error 를 반환한다. (어떤 경우에도 데이터가 달라져서는 안된다.)
이는 매 순간 Read / Write 에 따른 정합성이 일치할 필요가 있는 경우 적합한 형태이다.



- AP (Availability & Partition Tolerance) : 어떤 상황에서도 안정적으로 시스템은 운영된다. 또한 데이터와 상관없이 안정적인 응답을 받을 수 있다. 다만 데이터의 정합성에 대한 보장은 불가능하다. (특정 시점에 Write 동기화 여부에 따라 데이터가 달라질 수 있다.)
이는 결과적으로는 일관성이 보장된다는 Eventual Consistency 를 보장할 수 있는 시스템에 알맞는 형태이다.
</div>
</details>

### 파티셔닝


<details>
<summary>답변</summary>
<div markdown="1">

### 파티셔닝이 필요한 이유

- 데이터셋이 매우 클때
- 질의 처리량이 매우 높을때
- 확장성을 위해서 파티셔닝을 진행


파티셔닝의 목적 : 데이터와 질의 부하를 노드 사이에 균등하기 분산하는 것

극단적인 상황에서는 10개 중 9개가 유휴 상태에 있고 1개가 질의를 다 받는 핫스팟 문제가 발생할 수 있다.

핫스팟 문제를 해결하는 가장 간단한 방법
- 무작위 배치

단점 : 어떤 레코드가 어떤 노드에 배치됐는지 알지 못한다 → 요청이 들어오면 해당 데이터를 찾기 위해 모든 노드를 탐색해야 함

### 파티셔닝 방법

### 키 범위 기준 파티셔닝

각 파티션에 연속된 범위의 키를 할당하므로, 어떤 키가 어떤 파티션에 속하는지 쉽게 알 수 있다.

데이터 고르게 분산하기 위해서는 키 범위를 똑같이 할당하면 안되고 유동적으로 할당해야 한다.

- 장점 : 각 파티션 내에 키를 정렬된 상태로 저장 가능 → 범위 검색이 가능하다

- 단점 : 특정 접근 패턴이 핫스팟 유발할 수 있다.

만약 시간 단위로 키를 나눴을때 쓰기 작업은 모두 최근 날짜 파티션으로 쏠리게 된다 → 과부하 발생

### 키의 해시값 기준 파티셔닝

쏠림과 핫스팟 문제로 인해 실제 분산 데이터스토어는 해시 함수를 사용한다.

해시값을 구한 다음, 각 파티션에 해시값 범위를 지정한다. 범위에 해당하는 해시값을 할당해주면 된다.

- 단점 : 범위 질의를 할 수 없게 된다.

- 장점 : 핫스팟 제거에 도움이 된다. 하지만 완전히 제거는 불가능하다. Ex 유명인 검색

몽고 db에서는 해시 파티셔닝 사용하면 범위 질의가 모든 파티션에 대해서 이뤄져야 한다.


</div>
</details>

### ERD
<details>
<summary>답변</summary>
<div markdown="1">

엔티티간의 연관성을 표현하는 다이어그램

</div>
</details>
